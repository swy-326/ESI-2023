// Generated by CodiumAI

describe('OrderController', () => {

    // handleFindAll returns all orders when no query params are provided
    it('should return all orders when no query params are provided', async() => {
        const prismaMock = {
            orders: {
                findMany: jest.fn().mockResolvedValue([{ id: 1, title: 'Order 1' }, { id: 2, title: 'Order 2' }])
            }
        };

        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        const request = { query: {} };
        const response = {};

        await orderController.handleFindAll(request, response);

        expect(prismaMock.orders.findMany).toHaveBeenCalled();
        expect(response).toEqual([{ id: 1, title: 'Order 1' }, { id: 2, title: 'Order 2' }]);
    });

    // handleFindAll filters orders by tags, languages, and price when query params are provided
    it('should filter orders by tags, languages, and price when query params are provided', async() => {
        const prismaMock = {
            orders: {
                findMany: jest.fn().mockResolvedValue([{ id: 1, title: 'Order 1' }])
            }
        };

        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        const request = { query: { tags: 'tag1', languages: 'language1', price: '10' } };
        const response = {};

        await orderController.handleFindAll(request, response);

        expect(prismaMock.orders.findMany).toHaveBeenCalledWith({
            where: {
                AND: [
                    { tags: { hasSome: ['tag1'] } },
                    { languages: { hasSome: ['language1'] } },
                    { price: { gte: 10 } }
                ]
            },
            include: {
                user: {
                    select: {
                        avatar: true
                    }
                }
            }
        });
        expect(response).toEqual([{ id: 1, title: 'Order 1' }]);
    });

    // handleFindOne returns the order with the given id and includes user and answers data
    it('should return the order with the given id and includes user and answers data', async() => {
        const prismaMock = {
            orders: {
                findUnique: jest.fn().mockResolvedValue({
                    id: 1,
                    title: 'Order 1',
                    user: { name: 'User 1', avatar: 'avatar1.jpg' },
                    answers: [{ id: 1, answer: 'Answer 1', user: { name: 'User 2', avatar: 'avatar2.jpg' } }]
                })
            }
        };

        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        const request = { params: { id: 1 } };
        const response = {};

        await orderController.handleFindOne(request, response);

        expect(prismaMock.orders.findUnique).toHaveBeenCalledWith({
            where: { id: 1 },
            include: {
                answers: {
                    include: {
                        user: {
                            select: {
                                name: true,
                                avatar: true
                            }
                        }
                    }
                },
                user: {
                    select: {
                        name: true,
                        avatar: true
                    }
                }
            }
        });
        expect(response).toEqual({
            id: 1,
            title: 'Order 1',
            user: { name: 'User 1', avatar: 'avatar1.jpg' },
            answers: [{ id: 1, answer: 'Answer 1', user: { name: 'User 2', avatar: 'avatar2.jpg' } }]
        });
    });

    // handleFindAll returns an empty array when no orders match the query params
    it('should return an empty array when no orders match the query params', async() => {
        const prismaMock = {
            orders: {
                findMany: jest.fn().mockResolvedValue([])
            }
        };

        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        const request = { query: { tags: 'tag1', languages: 'language1', price: '10' } };
        const response = {};

        await orderController.handleFindAll(request, response);

        expect(prismaMock.orders.findMany).toHaveBeenCalledWith({
            where: {
                AND: [
                    { tags: { hasSome: ['tag1'] } },
                    { languages: { hasSome: ['language1'] } },
                    { price: { gte: 10 } }
                ]
            },
            include: {
                user: {
                    select: {
                        avatar: true
                    }
                }
            }
        });
        expect(response).toEqual([]);
    });

    // handleFindOne returns a 404 error when no order with the given id is found
    it('should return a 404 error when no order with the given id is found', async() => {
        const prismaMock = {
            orders: {
                findUnique: jest.fn().mockResolvedValue(null)
            }
        };

        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        const request = { params: { id: 1 } };
        const response = {
            code: jest.fn().mockReturnThis(),
            send: jest.fn()
        };

        await orderController.handleFindOne(request, response);

        expect(prismaMock.orders.findUnique).toHaveBeenCalledWith({
            where: { id: 1 },
            include: {
                answers: {
                    include: {
                        user: {
                            select: {
                                name: true,
                                avatar: true
                            }
                        }
                    }
                },
                user: {
                    select: {
                        name: true,
                        avatar: true
                    }
                }
            }
        });
        expect(response.code).toHaveBeenCalledWith(404);
        expect(response.send).toHaveBeenCalledWith({ error: "Order Not Found" });
    });

    // handleCreate returns an error object when there is an error creating the order
    it('should return an error object when there is an error creating the order', async() => {
        const prismaMock = {
            orders: {
                create: jest.fn().mockRejectedValue(new Error('Error creating order'))
            }
        };

        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        const request = { jwtVerify: jest.fn().mockResolvedValue({ internal_id: 1 }), body: {} };
        const response = {};

        await orderController.handleCreate(request, response);

        expect(prismaMock.orders.create).toHaveBeenCalled();
        expect(response).toEqual({ error: "Error" });
    });

    // handleAcceptOrder updates the translator_id of the order with the given id
    it('should update the translator_id of the order when handleAcceptOrder is called', async() => {
        const prismaMock = {
            orders: {
                update: jest.fn().mockResolvedValue({ id: 1, translator_id: 2 })
            }
        };

        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        const request = { params: { id: 1 }, jwtVerify: jest.fn().mockResolvedValue({ internal_id: 2 }) };
        const response = {};

        await orderController.handleAcceptOrder(request, response);

        expect(prismaMock.orders.update).toHaveBeenCalledWith({
            where: { id: 1 },
            data: { translator_id: 2 }
        });
        expect(response).toEqual({ id: 1, translator_id: 2 });
    });

    // handleAddResponse adds a new answer to the order with the given id and includes user data
    it('should add a new answer to the order and include user data', async() => {
        // Mock dependencies
        const prismaMock = {
            orders: {
                update: jest.fn().mockResolvedValue({
                    id: 1,
                    title: 'Order 1',
                    answers: [{
                        id: 1,
                        user: {
                            name: 'User 1',
                            avatar: 'avatar1.jpg'
                        }
                    }]
                })
            }
        };

        const requestMock = {
            params: {
                id: 1
            },
            jwtVerify: jest.fn().mockResolvedValue({
                internal_id: 123
            }),
            body: {
                answer: 'This is the answer'
            },
            files: [
                { filename: 'file1.jpg' },
                { filename: 'file2.jpg' }
            ]
        };

        const responseMock = {};

        // Import and initialize OrderController
        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        // Call the function under test
        await orderController.handleAddResponse(requestMock, responseMock);

        // Assertions
        expect(prismaMock.orders.update).toHaveBeenCalledWith({
            where: { id: 1 },
            data: {
                answers: {
                    create: [{
                        user_id: 123,
                        answer: 'This is the answer',
                        files: ['file1.jpg', 'file2.jpg']
                    }]
                }
            },
            include: {
                answers: {
                    include: {
                        user: {
                            select: {
                                name: true,
                                avatar: true
                            }
                        }
                    }
                },
                user: {
                    select: {
                        name: true,
                        avatar: true
                    }
                }
            }
        });

        expect(responseMock).toEqual({
            id: 1,
            title: 'Order 1',
            answers: [{
                id: 1,
                user: {
                    name: 'User 1',
                    avatar: 'avatar1.jpg'
                }
            }]
        });
    });

    // handleAddResponse returns an error object when there is an error updating the order
    it('should return an error object when there is an error updating the order in handleAddResponse', async() => {
        const prismaMock = {
            orders: {
                update: jest.fn().mockRejectedValue(new Error('Error updating order'))
            }
        };

        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        const request = { params: { id: 1 }, jwtVerify: jest.fn().mockResolvedValue({ internal_id: 1 }), body: { answer: 'Test answer' } };
        const response = {};

        const result = await orderController.handleAddResponse(request, response);

        expect(prismaMock.orders.update).toHaveBeenCalledWith({
            where: { id: 1 },
            data: {
                answers: {
                    create: [{
                        user_id: 1,
                        answer: 'Test answer',
                        files: undefined
                    }]
                }
            },
            include: {
                answers: {
                    include: {
                        user: {
                            select: {
                                name: true,
                                avatar: true
                            }
                        }
                    }
                },
                user: {
                    select: {
                        name: true,
                        avatar: true
                    }
                }
            }
        });
        expect(result).toEqual({ error: 'Error updating order' });
    });

    // handleAddRaiting returns an error object when there is an error updating the order
    it('should return an error object when there is an error updating the order', async() => {
        const prismaMock = {
            orders: {
                update: jest.fn().mockRejectedValue(new Error('Error updating order'))
            }
        };

        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        const request = { params: { id: 1 }, jwtVerify: jest.fn().mockResolvedValue({ internal_id: 1 }) };
        const response = {};

        const result = await orderController.handleAddRaiting(request, response);

        expect(prismaMock.orders.update).toHaveBeenCalledWith({
            where: { id: 1 },
            data: {
                raiting: {
                    create: {
                        user_id: 1,
                        stars: expect.any(Number),
                        description: expect.any(String),
                    }
                },
                completed: true
            }
        });
        expect(result).toEqual({ error: 'Error' });
    });

    // handleFindAll returns orders in descending order by creation date
    it('should return orders in descending order by creation date when handleFindAll is called', async() => {
        const prismaMock = {
            orders: {
                findMany: jest.fn().mockResolvedValue([{ id: 1, title: 'Order 1', createdAt: new Date(2022, 1, 1) }, { id: 2, title: 'Order 2', createdAt: new Date(2022, 1, 2) }])
            }
        };

        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        const request = { query: {} };
        const response = {};

        await orderController.handleFindAll(request, response);

        expect(prismaMock.orders.findMany).toHaveBeenCalled();
        expect(response).toEqual([{ id: 2, title: 'Order 2', createdAt: new Date(2022, 1, 2) }, { id: 1, title: 'Order 1', createdAt: new Date(2022, 1, 1) }]);
    });

    // handleFindOne sets canAnswerOrder to true when the order price is 0
    it('should set canAnswerOrder to true when the order price is 0', () => {
        // Mock data
        const order = {
            price: 0,
            user_id: 'user123',
            translator_id: 'translator123'
        };

        const prismaMock = {
            orders: {
                findUnique: jest.fn().mockResolvedValue(order)
            }
        };

        const OrderController = require('./order.controller');
        const orderController = OrderController(prismaMock);

        const request = { params: { id: 'order123' } };
        const response = { code: jest.fn().mockReturnThis(), send: jest.fn() };

        // Call the function under test
        orderController.handleFindOne(request, response);

        // Check the response
        expect(response.code).not.toHaveBeenCalled();
        expect(response.send).toHaveBeenCalledWith({
            ...order,
            canAnswerOrder: true,
            canRateOrder: false
        });
    });
});