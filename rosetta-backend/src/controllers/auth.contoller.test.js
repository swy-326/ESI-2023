// Generated by CodiumAI

describe('AuthController', () => {

    // Function successfully logs in a user with valid email and password
    it('should successfully log in a user with valid email and password', async() => {
        const fastify = {
            bcrypt: {
                compare: jest.fn().mockResolvedValue(true)
            },
            jwt: {
                sign: jest.fn().mockReturnValue('token')
            }
        }

        const request = {
            body: {
                email: 'test@example.com',
                password: 'password'
            }
        }

        const response = {
            code: jest.fn().mockReturnThis(),
            send: jest.fn()
        }

        const prisma = {
            users: {
                findFirst: jest.fn().mockResolvedValue({
                    id: 1,
                    internal_id: 'internal_id',
                    email: 'test@example.com',
                    password: 'hashed_password'
                })
            }
        }

        const authController = AuthController(fastify)
        await authController.handleLogin(request, response)

        expect(prisma.users.findFirst).toHaveBeenCalledWith({
            where: {
                email: 'test@example.com'
            }
        })

        expect(fastify.bcrypt.compare).toHaveBeenCalledWith('password', 'hashed_password')

        expect(fastify.jwt.sign).toHaveBeenCalledWith({
            id: 1,
            internal_id: 'internal_id',
            email: 'test@example.com'
        })

        expect(response.code).toHaveBeenCalledWith(200)
        expect(response.send).toHaveBeenCalledWith({
            token: 'token'
        })
    });

    // Function returns a JWT token upon successful login
    it('should return a JWT token upon successful login', async() => {
        const fastify = {
            bcrypt: {
                compare: jest.fn().mockResolvedValue(true)
            },
            jwt: {
                sign: jest.fn().mockReturnValue('token')
            }
        }

        const request = {
            body: {
                email: 'test@example.com',
                password: 'password'
            }
        }

        const response = {
            code: jest.fn().mockReturnThis(),
            send: jest.fn()
        }

        const prisma = {
            users: {
                findFirst: jest.fn().mockResolvedValue({
                    id: 1,
                    internal_id: 'internal_id',
                    email: 'test@example.com',
                    password: 'hashed_password'
                })
            }
        }

        const authController = AuthController(fastify)
        await authController.handleLogin(request, response)

        expect(fastify.jwt.sign).toHaveBeenCalledWith({
            id: 1,
            internal_id: 'internal_id',
            email: 'test@example.com'
        })

        expect(response.code).toHaveBeenCalledWith(200)
        expect(response.send).toHaveBeenCalledWith({
            token: 'token'
        })
    });

    // Function returns a 404 error if user is not found
    it('should return a 404 error if user is not found', async() => {
        const fastify = {
            bcrypt: {
                compare: jest.fn().mockResolvedValue(true)
            },
            jwt: {
                sign: jest.fn().mockReturnValue('token')
            }
        }

        const request = {
            body: {
                email: 'test@example.com',
                password: 'password'
            }
        }

        const response = {
            code: jest.fn().mockReturnThis(),
            send: jest.fn()
        }

        const prisma = {
            users: {
                findFirst: jest.fn().mockResolvedValue(null)
            }
        }

        const authController = AuthController(fastify)
        await authController.handleLogin(request, response)

        expect(prisma.users.findFirst).toHaveBeenCalledWith({
            where: {
                email: 'test@example.com'
            }
        })

        expect(response.code).toHaveBeenCalledWith(404)
        expect(response.send).toHaveBeenCalledWith({
            error: 'User Not Found'
        })
    });

    // Function returns a 500 error if there is an issue with the database connection
    it('should return a 500 error if there is an issue with the database connection', async() => {
        const fastify = {
            bcrypt: {
                compare: jest.fn().mockResolvedValue(true)
            },
            jwt: {
                sign: jest.fn().mockReturnValue('token')
            }
        }

        const request = {
            body: {
                email: 'test@example.com',
                password: 'password'
            }
        }

        const response = {
            code: jest.fn().mockReturnThis(),
            send: jest.fn()
        }

        const prisma = {
            users: {
                findFirst: jest.fn().mockRejectedValue(new Error('Database connection error'))
            }
        }

        const authController = AuthController(fastify)
        await authController.handleLogin(request, response)

        expect(prisma.users.findFirst).toHaveBeenCalledWith({
            where: {
                email: 'test@example.com'
            }
        })

        expect(response.code).toHaveBeenCalledWith(500)
        expect(response.send).toHaveBeenCalledWith({
            error: 'Database connection error'
        })
    });

    // Function returns a 400 error if email is missing or invalid
    it('should return a 400 error if email is missing or invalid', async() => {
        const fastify = {
            bcrypt: {
                compare: jest.fn().mockResolvedValue(true)
            },
            jwt: {
                sign: jest.fn().mockReturnValue('token')
            }
        }

        const request = {
            body: {
                password: 'password'
            }
        }

        const response = {
            code: jest.fn().mockReturnThis(),
            send: jest.fn()
        }

        const prisma = {
            users: {
                findFirst: jest.fn().mockResolvedValue(null)
            }
        }

        const authController = AuthController(fastify)
        await authController.handleLogin(request, response)

        expect(prisma.users.findFirst).not.toHaveBeenCalled()

        expect(response.code).toHaveBeenCalledWith(400)
        expect(response.send).toHaveBeenCalledWith({
            error: 'Invalid email'
        })
    });

    // Function returns a 400 error if password is missing
    it('should return a 400 error if password is missing', async() => {
        const fastify = {
            bcrypt: {
                compare: jest.fn().mockResolvedValue(true)
            },
            jwt: {
                sign: jest.fn().mockReturnValue('token')
            }
        }

        const request = {
            body: {
                email: 'test@example.com'
            }
        }

        const response = {
            code: jest.fn().mockReturnThis(),
            send: jest.fn()
        }

        const prisma = {
            users: {
                findFirst: jest.fn().mockResolvedValue(null)
            }
        }

        const authController = AuthController(fastify)
        await authController.handleLogin(request, response)

        expect(prisma.users.findFirst).not.toHaveBeenCalled()

        expect(response.code).toHaveBeenCalledWith(400)
        expect(response.send).toHaveBeenCalledWith({
            error: 'Password is required'
        })
    });
});